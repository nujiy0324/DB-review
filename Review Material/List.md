## 关系代数

查询优化，估计查询代价，转成sql语句

## sql

关系模式定义，primary key foreign key

sql查询，给关系模式，写查询语句

权限管理，触发器机制，事务管理语句，trans，事物的概念的体现，给关系模式，写trans，commit

## ER图

ER图描述，画ER，转关系模式

关系规范化：重点函数依赖，BCNF范式，覆盖，属性闭包，无损连接的分解，依赖保持的分解，知道是否为BCNF，如何无论连接成BCNF，判断是否依赖保持，XML（DTD，XML schema)，给instance，写DTD

Xpass表达式，给查询要求写Xpass表达式

XML：树形结构，给文档，要存，关系模式是怎样的，反过来，给关系模式，怎么转成XML

## DBMS实现

存储，索引：记录的表示，不定长记录的表示，**buffer缓冲区管理**，**B+树索引**

buffer缓冲区管理：给一个B+树，要读到内存，或者一个调度，给序列，看buffer怎么调度

查询处理和优化：基于关系代数表达式的优化，比如查询操作往叶子推，select组合成join，等价变换原则

重点：基于代价估计的，select操作，有哪些方法（无索引，有索引，通过根到叶子，从文件指针找到），B+和物理文件一样/不一样，B+树高度估算；连接操作：块、merging join：两个关系有序、（hash join）、index索引切到循环，内层有索引，外层通过索引来匹配记录，代价的估计，取决于外循环有多少记录，以及内层B+树的代价估算

排序：归并排序，代价估计

查询返回的规模多大：给select语句，估算查询返回多少记录，join操作的估计

查询优化拓展：增量

带有嵌套子查询的sql语句的处理：转成非嵌套的形式：看懂句子，用join连起来，*或/

**并发控制：**事物的SCID系统，并发控制协议：**两阶段**锁，第一阶段：加锁 第二阶段：放锁，能保证可串行化（冲突可串行化），反证 归纳

lock point：事物得到最后一个锁的时间

前驱图：给一个调度，交叉调度，判断是否可串行化，画前驱图，看是否包含环

严格两阶段附属协议：不能避免死锁，主要是为了把锁等到提交再释放，所以都可以回复，不会产生级联回滚

实现：通过数据库系统的模块：lock manager，通过hash table，来记录每个数据上的锁的状态，不能满足就放队列后面

死锁：解决死锁：1. 防止死锁产生 2. 如何处理死锁

防止死锁：1. 一次性获得所有的锁，在数据库里不好实现 2. 按照偏序关系 3. 规定事物等待的期限，基于超时，超过限制，把锁的请求撤回，避免陷入死锁

如何处理死锁：死锁检测：定时的死锁检测程序，去分析lock table的相互等待关系，等待图，画出有向图，如果有环就是死锁

意向锁

**alice恢复方法**

基于日志的方法，先写日志文件原则：因为两个操作：记日志，更新数据，两个操作中如果crash就可能危及，先写日志才能恢复，后写就不能恢复了

基于日志的恢复：checkpoint初衷：减少恢复过程的代价，否则要扫描整个日志文件，相当于把日志分段，在check之前的处理有限，最重要：alice恢复方法全部，搞清楚



alice分几个过程：三个：分析阶段，redo，undo阶段

分析过程：确定redo起点，确定哪些要undo，把页表更新到当前状态



relational database design

1. 都放一起的话，pid决定pname salary，sid决定sname，totcred，year和pid
2. key是sID和pID
3. 不是BCNF，肯定存在函数依赖，左边不是key
4. 缺陷：1. 信息冗余，2. 操作异常，比如有个教授没有带学生，没法插进去，无法存在，或者学生没有老师带的话，也没法存在，3. 修改复杂，一个老师带了很多学生，老师的salary要改的话要改很多，容易造成不一致
5. 转换为什么是无损的：判断依据：有公共属性，且是其中的key，公共属性是pid，而pid是某一个的key，所以是无损的，信息不会丢

relational formalization

1. 如果左边相同，合成一条 a->bc c->d d->e
2. bde
3. 不是BCNF，从叶子开始往回分解，R1(*D*,E) R2(*C*, D) R3(*A*, B, C)，F1:D->E, F2:C->D, F3:A->B, C
4. 查看是否每条依赖都能在R1R2R3中检验，但formal一点讲，依赖保持的定义是原来的F所有闭包 = F1并F2并F3的闭包

b+-tree

1. 从底向上，n = 4, 3 3 2，所以一共有两层
2. 估计B+树高度，最矮情况：最满：log4（近似，应该是log3）取整，半满，根两叉，除以二，然后log2向下取整，然后+1

problem 4

1. reader 1000, book 1000, borrow 79900

2. title unique

3. block size is 4K bytes

   问题：

4. 估算：8

buffer manager

1. 给了个序列，开始buffer为空，ABCDE调度，哪一个操作会引起buffer调度，buffer size是4，所以ABCD就满了，E进来会引起调度
2. B会扔出去，最早用到
3. 调换出去，之前要先写日志，先把log buffer写进去，再写出去
4. C1 conmmit提交的时候，修改的数据是否会被强制写出去（到磁盘）。事物提交的时候，修改的数据不一定被写出去，

2 phase locking protocol

1. 给个调度，看是否可串行，画前驱图
2. 在这里，那个事物最先获得最后一个锁，也就是串行的时候那个事物最后的，通过前驱图判断是否可串行，如果可串行，是否可以两阶段封锁协议产生（不是必要条件），如果可以，把lock unlock的协议排一下；如果不可以，怎么回答？ 可串行是两阶段封锁协议产生的充分不必要条件，是否由严格两阶段封锁协议产生

lock manager

有没有死锁产生，画出等待图

alice 算法

